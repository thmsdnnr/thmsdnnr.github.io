<!DOCTYPE html>
<html lang="en"><head>
	
	<meta name="generator" content="Hugo 0.76.0-DEV" />
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	
	<meta property="og:title" content="Binary Heaps: Min-Heaps and Max-Heaps">
	<link rel="preload" href="/webfonts/Roboto-Regular.woff" as="font" type="font/woff2">
	<link rel="stylesheet" type="text/css" media="screen" href="/css/main.css" />
	
	
	<meta name="author" content="Thomas Danner"><meta name="keywords" content="javascript,binaryHeap,queue,big-O,complexity,dataStructures,binaryTree"><meta name="description" content="Binary Heaps are binary-tree based data structures that can be used to implement a Priority Queue and provide O(1) insert and find-minimum performance."><meta property="og:title" content="Binary Heaps: Min-Heaps and Max-Heaps" />
<meta property="og:description" content="Binary Heaps are binary-tree based data structures that can be used to implement a Priority Queue and provide O(1) insert and find-minimum performance." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://thmsdnnr.com/post/binary-heaps-min-heaps-and-max-heaps/" />
<meta property="article:published_time" content="2018-02-12T06:56:04+00:00" />
<meta property="article:modified_time" content="2018-02-12T06:56:04+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Binary Heaps: Min-Heaps and Max-Heaps"/>
<meta name="twitter:description" content="Binary Heaps are binary-tree based data structures that can be used to implement a Priority Queue and provide O(1) insert and find-minimum performance."/>

	
	

	<title>Binary Heaps: Min-Heaps and Max-Heaps | full-stack overflow ðŸ¥ž</title></head>
<body><header>
	
	<div id="avatar">
		<a href="https://thmsdnnr.com/">
			
			
			<svg version="1.1" id="emoji" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
				 viewBox="0 0 72 72" enable-background="new 0 0 72 72" xml:space="preserve" alt="full-stack overflow ðŸ¥ž" width="80px" height="80px">
			<g id="_xD83D__xDE38__1_">
				<path fill="#F4AA41" d="M58.7,49.7C55.1,58.8,46,64.9,35.5,64.9c-9.1,0-19.3-5.8-22.9-15l-0.1-0.3c-1.1-2.9-2-6.4-2-9.6l3.7-33.4
					l11.2,11.1c2.9-1.2,6.1-1.9,9.5-1.9H36c3.4,0,6.6,0.7,9.5,1.9L56.7,6.6l3.7,33.9C60.5,43.7,59.8,46.8,58.7,49.7"/>
				<path fill="#E27022" d="M35.5,64.9c10.6,0.3,20.4-6,24-15.1l0.1-0.2c1.1-2.9,2-6.9,2-10.2L56.7,6.6"/>
					<line fill="none" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" x1="62" y1="54.9" x2="52.6" y2="49.7"/>
				<path fill="none" stroke="#1D1D1B" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" d="
					M52.6,47.7"/>
					<line fill="none" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" x1="57.8" y1="60.1" x2="48.5" y2="54.9"/>
				<path fill="none" stroke="#1D1D1B" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" d="
					M46.4,56"/>
				<path fill="none" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" d="
					M13.3,48.8c-1.1-2.8-1.7-5.8-1.7-9l3.6-32.8l11,10.7c2.9-1.2,6-1.9,9.3-1.9h1c3.3,0,6.4,0.7,9.3,1.9l11-10.7l3.6,32.8
					c0,3.2-0.6,6.2-1.7,9"/>
					<line fill="none" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" x1="10" y1="54.9" x2="19.4" y2="49.7"/>
				<path fill="none" stroke="#1D1D1B" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" d="
					M19.4,47.7"/>
					<line fill="none" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" x1="14.2" y1="60.1" x2="23.5" y2="54.9"/>
				<path fill="none" stroke="#1D1D1B" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" d="
					M25.6,56"/>
					<line fill="none" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" x1="31.8" y1="46.3" x2="40.2" y2="46.3"/>
					<path fill="#EA5A47" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" d="
					M25.6,49.4c0,0,7.8,4.2,10.4-3.1c2.6,7.3,10.8,3.1,10.8,3.1s-2.7,4.4-3.5,5.2c-4,4.3-9.4,4.1-13.7,0.1
					C28.7,53.8,25.6,49.4,25.6,49.4z"/>
				<path fill="none" stroke="#1D1D1B" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" d="
					M55.7,61"/>
				<path fill="none" stroke="#1D1D1B" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" d="
					M16.3,61"/>
				<path fill="none" stroke="#1D1D1B" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" d="
					M55.7,61"/>
				<path fill="none" stroke="#1D1D1B" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" d="
					M16.3,61"/>
				<path fill="none" stroke="#1D1D1B" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" d="
					M64,56.1"/>
				<path fill="none" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" d="
					M22.9,60.2c3.7,2.3,8,3.6,12.6,3.6h1c4.6,0,9-1.3,12.6-3.6"/>
				<path fill="none" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" d="
					M55.2,38.6c-3.1-4.2-9.3-4.2-11.4,0"/>
				<path fill="none" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" d="
					M16.8,38.6c3.1-4.2,9.3-4.2,11.4,0"/>
			</g>
			</svg>
		</a>
	</div>
	
	<div id="titletext"><h2 id="title"><a href="https://thmsdnnr.com/">full-stack overflow ðŸ¥ž</a></h2></div>
	<div id="title-description"><p id="subtitle">writing code ðŸ¤– drinking coffee â˜• petting cats ðŸ˜º wearing masks ðŸ˜·</p><div id="social">
			<nav>
				<ul></ul>
			</nav>
		</div>
	</div>
	
	<div id="mainmenu">
		<nav>
			<ul>
				
				<li><a href="/projects">Projects</a></li>
				
				<li><a href="/post">Blog</a></li>
				
				<li><a href="/tags">Tags</a></li>
				
				<li><a href="/categories">Categories</a></li>
				
				<li><a href="https://github.com/thmsdnnr">GitHub</a></li>
				
			</ul>
		</nav>
	</div>
	
</header>
<main><div class="post">
	
	<div class="author">
	
	</div>
	<div class="post-header">
	
		<div class="meta">
			
			<div class="date">
				<span class="day">12</span>
				<span class="rest">Feb 2018</span>
			</div>
			
		</div>
		
		<div class="matter">
			<h1 class="title">Binary Heaps: Min-Heaps and Max-Heaps</h1>
		</div>
	</div>
	<div class="markdown">
		<p><em>I owe much of my learning &amp; implementation to <a href="http://eloquentjavascript.net/1st_edition/appendix2.html" target="_blank" rel="noreferrer noopener">Eloquent Javascript</a>
 by Marijn Haverbeke.</em></p>
<p><a href="https://en.wikipedia.org/wiki/Binary_heap" target="_blank" rel="noreferrer noopener">Binary heaps</a>
 are partially ordered data structures in the form of binary trees. A binary heap orders elements such that parent nodes are either greater than/equal to their child nodes (max heap), or less than/equal to their child nodes (min heap).</p>
<p>A heap is a <em>full</em> binary tree (every node except leaves have two children) and <em>complete</em> binary tree (every level except possibly the last is filled; all nodes are as far left as they can be).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">min-heap:
      1
    /   \
   2     3
 /  \   / \
4   11

max-heap:
      11
    /    \
   4      3
 /  \    / \
2    1
</code></pre></div><p>Note that a binary heap is <em>not</em> a Binary Search Tree.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">   1
 /   \
3     2
</code></pre></div><h5 id="this-is-a-valid-min-heap-but-an-invalid-binary-search-tree">This is a valid min-heap, but an invalid binary search tree.</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">   1
 /   \
2     3
</code></pre></div><h5 id="this-is-a-valid-min-heap-that-also-happens-to-be-a-binary-search-tree">This is a valid min-heap that also happens to be a binary search tree.</h5>
<p>In a Binary Search Tree, the left child is less than the parent and the right child is greater than the parent. In a Binary Heap, there is no ordering of the children relative to the parent other than children being strictly less or strictly greater than the parent.</p>
<h2 id="big-o-breakdown">Big-O Breakdown</h2>
<p>Binary Heaps have O(log n) complexity for insertion and deletion in the worst case, and O(1) complexity for removal (of the min or max element).</p>
<p>To insert an element, we add it to the very end of the tree and then swap its position with adjacent nodes until it satisfies the ordering property of the heap.</p>
<p>We can delete a specified element from the heap in O(log n) time by performing a binary search for the element and then removing it. However, min and max heaps are optimized for removal of the root element in O(1) time, rather than supporting arbitrary deletion.</p>
<h2 id="implementing-heaps">Implementing Heaps</h2>
<p>Heaps are <a href="https://en.wikipedia.org/wiki/Binary_heap#Heap_implementation" target="_blank" rel="noreferrer noopener">often implemented using an array</a>
. When implementing a heap as an array, we&rsquo;re creating what&rsquo;s called an <a href="https://en.wikipedia.org/wiki/Implicit_data_structure" target="_blank" rel="noreferrer noopener">implicit data structure</a>
. Whereas in a traditional binary tree implementation</p>
<p>Given a tree array with index starting at 1, for any element with index idx, its parent is located at <code>Math.floor(idx/2)</code>, and its two children are located at <code>2*idx</code> and <code>2*idx+1</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">min-heap:

        1
      /   \
     2     3
   /  \   / \      
  4   11

1-indexed array:
values:  x  1  2  3  4  11
indices: 0  1  2  3  4   5

0-indexed array:
values:  1  2  3  4 11
indices: 0  1  2  3  4
</code></pre></div><p>We could start the array at index 0, but it would make the math just a little uglier.</p>
<p>If we did use a zero indexed array, the left and right children would be located at <code>idx*2+1</code> and <code>idx*2+2</code> respectively, and the parent would be located at <code>Math.floor((idx-1)/2)</code>.</p>
<h2 id="simple-binaryheap-object">Simple BinaryHeap Object</h2>
<p>Let&rsquo;s implement a Binary Heap.</p>
<p>We&rsquo;ll let the user supply a comparator function that will provide a &ldquo;score&rdquo; for each element that will be used to compare two elements. The heap will be a array with index starting at 1 to simplify subscripts for parents and children. The zero index, null, will never be accessed.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#8be9fd;font-style:italic">var</span> BinaryHeap <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">function</span> (comparator) {
  <span style="color:#ff79c6">this</span>.heap <span style="color:#ff79c6">=</span> [<span style="color:#ff79c6">null</span>];
  <span style="color:#ff79c6">this</span>.comparator <span style="color:#ff79c6">=</span> comparator;
};
</code></pre></div><p>If we&rsquo;re ordering numbers or other elements with lexicographic ordering, the scoring function can just be the identity function: <code>function(x) { return x; }</code>. The scoring function allows us to define either a minimum or a maximum heap (by changing the sign of the returned element).</p>
<p>To start, we&rsquo;ll define a few helper methods. <code>score</code> will just call the specified comparator function on a given value of an element at index <code>idx</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">BinaryHeap.prototype.score <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">function</span> (idx) {
  <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">this</span>.comparator.call(<span style="color:#ff79c6">this</span>, <span style="color:#ff79c6">this</span>.heap[idx]);
};
</code></pre></div><p><code>maxIdx</code> returns the current heap <code>length-1</code>, which represents the largest array index we can match without going out of bounds.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">BinaryHeap.prototype.maxIdx <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">function</span> () {
  <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">this</span>.heap.length <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>;
};
</code></pre></div><p><code>swap</code> swaps two values in the heap at indices a and b.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">BinaryHeap.prototype.swap <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">function</span> (a, b) {
  <span style="color:#8be9fd;font-style:italic">var</span> temp <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">this</span>.heap[b];
  <span style="color:#ff79c6">this</span>.heap[b] <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">this</span>.heap[a];
  <span style="color:#ff79c6">this</span>.heap[a] <span style="color:#ff79c6">=</span> temp;
};
</code></pre></div><h3 id="insert--push">Insert / Push</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">BinaryHeap.prototype.push <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">function</span> (value) {
  <span style="color:#ff79c6">this</span>.heap.push(value);
  <span style="color:#ff79c6">this</span>.bubbleUp(<span style="color:#ff79c6">this</span>.heap.length <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>);
};
</code></pre></div><p>To insert values, we simply push them onto the end of the array and then call <code>bubbleUp</code> with the index of the newly inserted element. What does bubbleUp do?</p>
<p><code>bubbleUp</code> moves the newly inserted element up in the tree until its score is greater than or equal to that of its parent.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">BinaryHeap.prototype.bubbleUp <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">function</span> (idx) {
  <span style="color:#ff79c6">while</span> (idx <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">1</span>) {
    <span style="color:#8be9fd;font-style:italic">var</span> eleScore <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">this</span>.score(idx);
    <span style="color:#8be9fd;font-style:italic">var</span> parentIdx <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">Math</span>.floor(idx <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">2</span>);
    <span style="color:#8be9fd;font-style:italic">var</span> parentScore <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">this</span>.score(parentIdx);
    <span style="color:#ff79c6">if</span> (eleScore <span style="color:#ff79c6">&lt;</span> parentScore) {
      <span style="color:#ff79c6">this</span>.swap(parentIdx, idx);
      idx <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">Math</span>.floor(idx <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">2</span>);
    } <span style="color:#ff79c6">else</span> {
      <span style="color:#ff79c6">break</span>;
    }
  }
};
</code></pre></div><p>If the score is less than that of the parent, we want to swap out the current index with the index of the parent. The parent index is always given by the floor of the current index divided by two, so long as <code>idx&gt;1</code>. Remember, we are never accessing idx=0, and when idx=1, Math.floor(idx/2) =&gt; Math.floor(1/2) =&gt; 0.</p>
<h3 id="delete--pop">Delete / Pop</h3>
<p>We must account for the fact that children are not necessarily ordered when we delete or &ldquo;pop&rdquo; from the heap. The algorithm for deletion is:</p>
<ol>
<li>Remove the element at index 1. This is the value that will be returned.</li>
<li>Pop the last value from the heap. This is the value we&rsquo;ll use to replace index 1.</li>
<li>Make sure the index 1 element !== the last value from the heap.</li>
</ol>
<ul>
<li>If it does, we&rsquo;re removing the final element from the heap: simply return it.</li>
</ul>
<ol start="4">
<li>If the index 1 element isn&rsquo;t the last value of the heap, put the last value at index 1.</li>
<li>Call <code>siftDown</code> on the element at index 1.</li>
</ol>
<p><code>siftDown</code> is a method that propagates a newly added element down the tree until it is in the proper place given the heap&rsquo;s ordering.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">BinaryHeap.prototype.siftDown <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">function</span> (idx) {
  <span style="color:#ff79c6">const</span> max <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">this</span>.maxIdx();
  <span style="color:#ff79c6">while</span> (idx <span style="color:#ff79c6">&lt;</span> max) {
    <span style="color:#8be9fd;font-style:italic">var</span> eleScore <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">this</span>.score(idx);
    <span style="color:#8be9fd;font-style:italic">var</span> leftChild <span style="color:#ff79c6">=</span> idx <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">2</span>;
    <span style="color:#8be9fd;font-style:italic">var</span> rightChild <span style="color:#ff79c6">=</span> leftChild <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>;
    <span style="color:#8be9fd;font-style:italic">var</span> swap <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">null</span>;
    <span style="color:#ff79c6">if</span> (leftChild <span style="color:#ff79c6">&lt;=</span> max) {
      <span style="color:#8be9fd;font-style:italic">var</span> leftChildScore <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">this</span>.score(leftChild);
      <span style="color:#ff79c6">if</span> (leftChildScore <span style="color:#ff79c6">&lt;</span> eleScore) {
        swap <span style="color:#ff79c6">=</span> leftChild;
      }
    }
    <span style="color:#ff79c6">if</span> (rightChild <span style="color:#ff79c6">&lt;=</span> max) {
      <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">this</span>.score(rightChild) <span style="color:#ff79c6">&lt;</span> (swap <span style="color:#ff79c6">?</span> leftChildScore <span style="color:#ff79c6">:</span> eleScore)) {
        swap <span style="color:#ff79c6">=</span> rightChild;
      }
    }
    <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>swap) {
      <span style="color:#ff79c6">break</span>;
    } <span style="color:#ff79c6">else</span> {
      <span style="color:#ff79c6">this</span>.swap(idx, swap);
      idx <span style="color:#ff79c6">=</span> swap;
    }
  }
};
</code></pre></div><p>What we&rsquo;re doing is this:</p>
<ol>
<li>Calculating the index for leftChild and rightChild</li>
<li>Ensuring the index is in bounds</li>
<li>If the index is in bounds, comparing the element score with the given child&rsquo;s score.</li>
<li>If the element has a score greater than one of the children&rsquo;s scores, we need to swap these two elements.</li>
</ol>
<p>For each iteration of the loop in <code>siftDown</code>, assuming that a left and right child exist, the inserted element could either be:</p>
<ol>
<li>In the correct place (<code>break</code> the loop)</li>
<li>Greater than the left child but less than the right child (swap the left child and the element)</li>
<li>Greater than both the left and the right child (swap the right child and the element)</li>
</ol>
<p>After performing the comparisons, we check to see if we are due to swap elements. If so, we perform the swap between the element and either the left or the right child.</p>
<p>The most confusing part is the ternary expression <code>if (this.score(rightChild) &lt; (swap ? leftChildScore : eleScore))</code> in the <code>if (rightChild &lt;= max)</code> block.</p>
<p>This is required because it could be that the value of the inserted element is greater than the <code>leftChild</code> value but less than the <code>rightChild</code> value. In this case, we would not want to swap the element with <code>rightChild</code>.</p>
<p>Consider this tree that illustrates the case:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">   4 (A)
 /     \
3 (B)   7 (C)
</code></pre></div><p>If we did swap the element with the right child, we know it would create an invalid heap: for three numbers A, B, C, if A &gt; B &lt; C, it follows that A &lt; C, and C cannot become A&rsquo;s parent. B can become the parent of A and C, however.</p>
<p>Without the ternary expression, the tree above would become this (if we just compared the inserted element&rsquo;s score with each child individually):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">  7
 / \
3   4
</code></pre></div><p>For each parent (A) we ask: is A greater than B? If not, we&rsquo;re done. If so, then we&rsquo;re going to swap it <em>at least</em> with B, and potentially with C as well. Now is C less than B? If not, swap A and B. Otherwise, swap A and C. Now consider the new tree generated by the movement to the left (swapping A with B) or right (swapping A with C).</p>
<p>Repeat until either A is less than both its left (B) and right (C) child or until we reach the end of the tree.</p>
<p>Let&rsquo;s visualize how this algorithm works for the following min-heap:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">       4
    /     \
   9       14
 /   \    /  \
14   12  30  10
</code></pre></div><p>Note again this is a valid min-heap but an invalid binary search tree.</p>
<p>We remove the element 4.</p>
<p>4 does not equal the last element in the tree (10), so we know the tree is not empty.</p>
<p>We swap 10 with 4&rsquo;s position. The tree now looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">       10
    /     \
   9       14
 /   \    /  \
14   12  30   
</code></pre></div><p>We then call <code>siftDown</code> on 8. Let&rsquo;s trace it through the tree. leftChild is 10, and rightChild is 8.</p>
<p>9 is less than 10, so swap is equal to 10.
14 is not less than 10, so we swap out 9 and 10.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">       9
    /     \
  10       14
 /   \    /  \
14   12  30   
</code></pre></div><p>Now we continue comparing, since we are not yet at <code>idx==max</code>.</p>
<p>leftChild is 14. 10 is not greater than 14, so we continue.
rightChild is 12. swap is null, so we compare the rightChild score with the element score.</p>
<p>The right child is not less than the element, so we&rsquo;re done.</p>
<p>Notice this is a complete binary tree (but not a binary <em>search</em> tree): all levels are filled to the maximum amount, and unfilled levels are populated from left-to-right.</p>
<p>Consider another shorter case where a deletion happens to place the element in the correct position from the start (best-case insertion):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">      4
   /     \
  10      7
 /  \    /  \
14  12  9    8
</code></pre></div><p>We remove the element 4.</p>
<p>4 does not equal the last element in the tree (8), so we know the tree is not empty.</p>
<p>We swap 8 with 4&rsquo;s position. The tree now looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">      8
   /     \
  10      7
 /  \    /  \
14  12  9    
</code></pre></div><p>We then call <code>siftDown</code> on 8. Let&rsquo;s trace it through the tree. leftChild is 10, and rightChild is 8.</p>
<p>10 is <em>not</em> less than 8, so swap is equal to 10.
8 is not less than 8, so we stop.</p>
<h2 id="heapsort">HeapSort</h2>
<p>Organizing elements in a binary heap gives them the convenient property of being able to be sorted very quickly. Notice that each time we perform a <code>pop</code> operation on a min-heap, we retrieve the next ascending sorted element of the heap&rsquo;s values; similarly, when we <code>pop</code> a max-heap, we retrieve the next descending sorted element.</p>
<p>This can be used to implement a priority queue by high or low priority.</p>
<p>We can also use this ordered property of heaps to implement <a href="https://en.wikipedia.org/wiki/Heapsort" target="_blank" rel="noreferrer noopener">HeapSort</a>
.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">BinaryHeap.prototype.heapSort <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">function</span> () {
  <span style="color:#ff79c6">const</span> copy <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">this</span>.heap.slice(<span style="color:#bd93f9">0</span>);
  <span style="color:#8be9fd;font-style:italic">let</span> res <span style="color:#ff79c6">=</span> [];
  <span style="color:#ff79c6">const</span> max <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">this</span>.maxIdx();
  <span style="color:#ff79c6">for</span> (<span style="color:#8be9fd;font-style:italic">var</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> max; i<span style="color:#ff79c6">++</span>) {
    res.push(<span style="color:#ff79c6">this</span>.pop());
  }
  <span style="color:#ff79c6">this</span>.heap <span style="color:#ff79c6">=</span> copy;
  <span style="color:#ff79c6">return</span> res;
};
</code></pre></div><p>We don&rsquo;t want to destroy the heap when we return its elements in a sorted manner, so we want to somehow copy and restore the heap after the sorting operation. There are a few ways that we could go wrong in implementing this.</p>
<ol>
<li>We might think that we could just say: <code>for (var i=0; i&lt;this.maxIdx(); i++)</code>.</li>
</ol>
<ul>
<li>This is a bad idea: <code>this.maxIdx()</code> changes with each invocation of <code>this.pop()</code> since removing an element shortens an array by one each time. We&rsquo;ll only get halfway through the array and then stop.</li>
</ul>
<ol start="2">
<li>We might think that we can copy the heap like this: <code>const copy = this.heap</code>.</li>
</ol>
<ul>
<li>This would be incorrect: <code>copy</code> would hold a <em>reference</em> to <code>this.heap</code>, but not the <em>value</em> of <code>this.heap</code>. Using <code>array.slice()</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank" rel="noreferrer noopener">(Docs)</a>
 solves this problem, but with a caveat! Note from the documentation that <code>Array.slice</code> will copy strings, numbers, and booleans, <em>but not objects</em>.</li>
</ul>
<p>If our heap contains an array of objects that we order by a given key, say <code>priority</code>, heapSort will wipe out each of these elements, because <code>copy</code> will contain an array of <em>references</em>, not a deep copy of the objects contained.</p>
<p>To implement this copying in a robust manner, we should really define a custom copy method for our array, so that we could simply say: <code>copy = this.copyHeap()</code>.</p>
<p>If the objects in the heap are large enough, it would make far more sense to simply create a map between heap indices and the key upon which they are sorted, sort the map array, and return it. This array, when iterated through from start to finish, will be the order in which we access elements of the heap to read them in ascending or descending order.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">BinaryHeap.prototype.orderMap <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">function</span> (dir <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>) {
  <span style="color:#6272a4">// 1 ascending, -1 descending
</span><span style="color:#6272a4"></span>  <span style="color:#8be9fd;font-style:italic">let</span> priorities <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">this</span>.heap
    .map((e, idx) =&gt; (
      idx <span style="color:#ff79c6">!==</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">?</span> { key<span style="color:#ff79c6">:</span> <span style="color:#ff79c6">this</span>.comparator(e), idx<span style="color:#ff79c6">:</span> idx } <span style="color:#ff79c6">:</span> <span style="color:#ff79c6">null</span>
      )
    ).filter((e) =&gt; e);
  <span style="color:#ff79c6">return</span> priorities.sort((a, b) =&gt; a.key <span style="color:#ff79c6">&gt;=</span> dir <span style="color:#ff79c6">*</span> b.key).map((e) =&gt; e.idx);
};
</code></pre></div><p>Since the elements are stored in an array for which we can look up the value of any cell in O(1) time, sorting is actually just an abstract operation of accessing cells in sorted <em>order</em>. Whether or not the cells are sorted when accessed in ascending or descending sequence of its index is incidental, and just an often convenient convention.</p>
<p>Indeed, it would perhaps make more sense to store a reference to each priority object in an array that is bound to a key on which we sort by and instead insert these priority-&gt;reference mappings into a heap. Making these decisions is implementation-specific, but it&rsquo;s good to think about the different ways you could achieve the same ends.</p>
<p>It is of course trivial to sort a heap that already exists. If we had an unsorted array, say, [3, 4, 70, 13, 11, -4, 7], we could easily sort it using heapSort like so:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#8be9fd;font-style:italic">function</span> heapSortArray(arr, dir <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>) {
  <span style="color:#8be9fd;font-style:italic">let</span> sortedArray <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> BinaryHeap((x) =&gt; dir <span style="color:#ff79c6">*</span> x);
  <span style="color:#ff79c6">for</span> (<span style="color:#8be9fd;font-style:italic">var</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> arr.length; i<span style="color:#ff79c6">++</span>) {
    sortedArray.push(arr[i]);
  }
  <span style="color:#ff79c6">return</span> sortedArray.heapSort();
}
</code></pre></div><h3 id="converting-a-min-heap-into-a-max-heap">Converting a min heap into a max heap</h3>
<p>It&rsquo;s an interesting tidbit that we can convert a min heap into a max heap (or vice versa) by reversing the comparator function&rsquo;s direction and then calling <code>siftDown</code> on indices <code>[Math.floor(heapLength/2), ..., 1]</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#8be9fd;font-style:italic">let</span> T <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> BinaryHeap(<span style="color:#8be9fd;font-style:italic">function</span> (x) {
  <span style="color:#ff79c6">return</span> x;
});
T.push(<span style="color:#bd93f9">4</span>);
T.push(<span style="color:#bd93f9">3</span>);
T.push(<span style="color:#bd93f9">5</span>);
T.push(<span style="color:#bd93f9">7</span>);
T.push(<span style="color:#bd93f9">13</span>);
T.push(<span style="color:#bd93f9">22</span>);

console.log(T.heapSort());
<span style="color:#6272a4">// [3, 4, 5, 7, 13, 22]
</span><span style="color:#6272a4"></span>
T.comparator <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">function</span> (x) {
  <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">-</span>x;
};
<span style="color:#8be9fd;font-style:italic">let</span> len <span style="color:#ff79c6">=</span> T.maxIdx();
<span style="color:#ff79c6">for</span> (<span style="color:#8be9fd;font-style:italic">var</span> i <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">Math</span>.floor(len <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">2</span>); i <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">0</span>; i<span style="color:#ff79c6">--</span>) {
  T.siftDown(i);
}
console.log(T.heapSort());
<span style="color:#6272a4">// [22, 13, 7, 5, 4, 3]
</span></code></pre></div><p>This is an application of <a href="https://en.wikipedia.org/wiki/Binary_heap#Building_a_heap" target="_blank" rel="noreferrer noopener">Floyd's method of heap construction</a>
 applied in-place to an existing heap structure. Kinda cool!</p>
<h2 id="wrapping-up">Wrapping Up</h2>
<p>Congratulations! You&rsquo;ve mastered yet another simple data structure. Try reviewing the structures you&rsquo;ve already learned and, most important, <em>coding them from scratch</em>, perhaps even with a pen and paper. It&rsquo;s one thing to read code and conceptually understand. It&rsquo;s far different to wrestle with off-by-one errors and indexing foibles.</p>
<p>Practice hones intuition, and sufficient intuition is indiscernible from mastery.</p>

	</div>
	
	
	
	
	
	
	
	<div class="tags">
		<div class="taxosfloating_left">
			<p>Categories</p>
		</div>
		<div class="termsfloating_right">
			<p>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/categories/computer-science/"> computer-science </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/categories/tutorials/"> tutorials </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			</p>
		</div>
		<div class="clearit"></div>
		
		
		
		
	
		
	
	
	
	<div class="tags">
		<div class="taxosfloating_left">
			<p>Tags</p>
		</div>
		<div class="termsfloating_right">
			<p>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/tags/big-o/"> big-o </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/tags/binaryheap/"> binaryheap </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/tags/binarytree/"> binarytree </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/tags/complexity/"> complexity </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/tags/datastructures/"> datastructures </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/tags/javascript/"> javascript </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<a href="/tags/queue/"> queue </a>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			</p>
		</div>
		<div class="clearit"></div>
		
		
		
		
		
	</div></div>

  </main>
<footer>
	 Â© 2017-2020 thomas danner // <a href="https://github.com/dataCobra/hugo-vitae">Vitae</a> theme for <a href="https://gohugo.io">Hugo</a> 
	
	
	
</footer>


</body>
</html>
